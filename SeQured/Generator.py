import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import neurokit2 as nk
from scipy.fft import fft, fftfreq, ifft
import base64
import qrcode

'''
NeuroKit2

Makowski, D., Pham, T., Lau, Z. J., Brammer, J. C., Lespinasse, F., Pham, H.,
Schölzel, C., & Chen, S. A. (2021). NeuroKit2: A Python toolbox for neurophysiological signal processing.
Behavior Research Methods, 53(4), 1689–1696. https://doi.org/10.3758/s13428-020-01516-y 
'''

'''
Required Libraries
The Basic Trinity: NumPy, Pandas, Matplotlib
NeuroKit2: For ECG Generation
SciPy: For Fourier Transforms
Base64: For converting between binary and Base64 code
QRCode: For generating QR Codes

Note: Matplotlib can be avoided if need be. It is only required for plotting the graphs if one needs to. (see end of file)
'''

#ECG Simulation Parameters
d= 1    #Duration of measurement
s= 500  #Rate of sampling
h= 70   #Heart beat
n= d*s  #Number of samples
#Note: Duration and Sampling needs to be managed to ensure ECG fits in the QR Code
#Alternatively, choose a subset of the Signal that will fit in a QR Code

#Distortion factors
k= 2    #k is the noise factor
l= 6    #l is the stretch factor
m= 3    #m is the decay factor

#Key generation
#The bitstring should be generated by the Quantum Computer before this point, it is stored in key
key = '01100011111100100111111001111101001100110101110110010011100001110010000000110110111010100101000000110110010001110000000111001100010000001000101101100111111100011000001100101011101000011111111111011101000100101001010110011000000010111001101011010010011011010110000011110101001101011111101110000111011111001111011010001110010110010100110101011001101010100100110011010010001101'
key_list = [int(key[i:i+32],base=2) for i in range(0,32*11, 32)] #Generating 11 uint32 numbers and storing it in the array, int() automatically stores the values as if they are uint32
key_array = np.uint32(key_list)     #Storing converting key list to a numpy array

#Saving the key
#Key is currently saved in txt file for convenience. Alternative and more secure methods can be used in the future.
key_array2 = np.int32(key_array)    #Converting the values from uint32 to int32
np.savetxt('key.txt', key_array2, delimiter='\n')   #Storing the keys as a txt file
    
#Generating the ECG graph
ecg = nk.ecg_simulate(duration=d, sampling_rate=s, heart_rate=h)

#Applying Fourier Transform on the ECG signal
ft_ecg = fft(ecg)
xf = fftfreq(n, 1/s)   #Obtaining the frequency for plotting the Fourier Transforms

#Creating the array with the distortion to apply
#Manipulate the distortion factors to control the distortion
np.random.seed(key_array) #Seed for the generator is only valid for one random function call (number or 1-d array)
distortion_array = np.complex128(np.random.rand(n)-0.5)/k  #Shifting values from 0-1 to -0.5 to 0.5, then dividing by k
for i,v in enumerate(distortion_array):
    x = i
    x = (x/n)*l
    distortion_array[i] = distortion_array[i] * (1/(1+x)**m)    
distortion_array = np.exp(1j*2*np.pi*distortion_array)

#Applying the distortion (by multiplying the scaling)
mft_ecg = np.complex128(ft_ecg)*distortion_array

#Applying Inverse Fourier Transform (to obtain modified ECG in time domain)
m_ecg = ifft(mft_ecg)

#Convert the complex number array to float64 (Inverse Fourier Transform returns Complex number array, not float)
m_ecg_real = m_ecg.real

#Float64 to Int16 (Normalizing the float) 
scale = 1.7+0.6     #Static Scale
#scale = np.max(m_ecg_real) - np.min(m_ecg_real)    #Dynamic Scale (need to find a way to send this scale to the decoder)
INT_16_MAX = 2**14
normalized = np.int16(m_ecg_real*INT_16_MAX/scale)  #Normalized Array containing int16
    
#Converting the Float16 array into bytes (binary)
norm_string = normalized.tobytes()

#Encoding byte string to Base64 
norm64_array = base64.b64encode(norm_string)

#Writing the base64 string to a txt file
f=open("base64_debug.txt", "wb") 
f.write(norm64_array)
f.close()

#Embedding the base64 string into a QR code
#More information can be stored in the QRCode by increasing the version number (up to 40)
#Note: More information = More detailed QR = More difficulty in scanning
qr = qrcode.QRCode(
version=26,
error_correction=qrcode.constants.ERROR_CORRECT_L,
box_size=5,
border=4,
)
qr.add_data(norm64_array)
qr.make(fit=False)  #This will cause an error if the information cannot fit the QR Version
img = qr.make_image(fill_color="black", back_color="white")
img.save("QR_Code.png") #Saving the QR Code

#Debug
plt.figure(1)
plt.plot(range(0,n),m_ecg_real,range(0,n),ecg)
plt.gca().legend(('Distorted ECG','ECG'))
plt.show()